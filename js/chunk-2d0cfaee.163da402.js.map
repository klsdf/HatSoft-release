{"version":3,"sources":["webpack:///./src/views/Computer/JavaScript/JavaScript.vue?3d0a","webpack:///./src/views/Computer/JavaScript/JavaScript.js","webpack:///src/views/Computer/JavaScript/JavaScript.vue","webpack:///./src/views/Computer/JavaScript/JavaScript.vue?cedc","webpack:///./src/views/Computer/JavaScript/JavaScript.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","attrs","content","staticRenderFns","components","MarkdownItVue","data","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACA,EAAG,kBAAkB,CAACE,YAAY,UAAUC,MAAM,CAAC,QAAUP,EAAIQ,YAAY,IACnLC,EAAkB,G,qBCDP,G,UAAA,8xLCUf,GACEC,WAAY,CACVC,cAAJ,KAEEC,KAJF,WAKI,MAAO,CACX,aChBkX,I,YCO9WC,EAAY,eACd,EACAd,EACAU,GACA,EACA,KACA,KACA,MAIa,aAAAI,E","file":"js/chunk-2d0cfaee.163da402.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('markdown-it-vue',{staticClass:\"md-body\",attrs:{\"content\":_vm.content}})],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default \r\n`\r\n# 基础知识\r\n\r\n本文采用了最新的es6语法,可以放心食用.\r\n\r\n## 专业术语\r\n\r\n为了防止在文中反复解释一些术语,我将一些常用术语的解释放在了这里.这意味着你并不需要直接看这里.等之后遇到了这些术语再翻上来看才是正道.\r\n\r\n### ES6\r\n\r\n### 字面量\r\n\r\n字面量就是代码意义上的常量,说白了就是可以放到赋值号右边的都可以叫字面量.这样子这个赋值表达式的值就如字面上一样,你赋值号右边写的是啥,值就是啥,非常容易理解.\r\n\r\n**注意,我下面代码中赋值语句的右边是字面量,我写这个语句只是方便理解,别理解错了.**\r\n\r\n\\`\\`\\`javascript\r\nvar 字符串字面量 = \"hello world!\";\r\nvar 数值字面量 = 996;\r\nvar 数组字面量 = [\"java\",\"c++\",\"JavaScript\"];\r\nvar 函数字面量 = function(){}\r\nvar 对象字面量 = {}\r\n\\`\\`\\`\r\n\r\n### 函数与方法\r\n\r\n理论上对象的函数就叫做方法,但是JavaScript是纯面向对象的语言,万物皆对象.所以函数和方法并没有C++那种半面向对象语言那种严格.一般来讲,window对象的方法叫做函数,其他对象的函数叫做方法,不过也没有那么较真就是了.\r\n\r\n## 关于结尾的分号\r\n\r\nJavaScript并没有强制要求你加上分号,也没有要求一定不加,一般情况下看自己喜好就行.\r\n\r\n不过只有这么两种情况下必须加分号:\r\n\r\n## 双引号与单引号\r\n\r\nJavaScript不区分单引号和双引号,字符串可以随意用这两种引号,不像其他语言严格取分大小写\r\n\r\n## Hello World\r\n\r\n浏览器环境下,直接打开浏览器,F12找到console就能看到.\r\n\r\n\\`\\`\\`html\r\n<!DOCTYPE html>\r\n<html>\r\n\t<head>\r\n\t\t<meta charset=\"utf-8\">\r\n\t\t<title></title>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\tconsole.log(\"Hello World\");\r\n\t\t</script>\r\n\t</head>\r\n\t<body>\r\n\t</body>\r\n</html>\r\n\r\n\\`\\`\\`\r\n\r\nnode环境下,用node命令执行语句.\r\n\r\n\\`\\`\\`javascript\r\nconsole.log(\"Hello World\");\r\n\\`\\`\\`\r\n\r\n\r\n\r\n# 值类型\r\n\r\n# 引用类型之字符串\r\n\r\n## 定义与使用\r\n\r\n\\`\\`\\`javascript\r\n//用字面量创建\r\nvar dream =\"愿天下没有996!\";\r\n\\`\\`\\`\r\n\r\n\r\n\r\n## 字符串常用方法\r\n\r\nes6 新增字符串方法\r\n\r\n- includes()\r\n\r\n- startWith()\r\n\r\n  \\`\\`\\`javascript\r\n  //字符串开头字母之后的字符串是否为h\r\n  str.startWith(\"h\");\r\n  //字符串开头第2个字母之后的字符串是否为ello\r\n  str.startWith(\"ello\",1);\r\n  \\`\\`\\`\r\n\r\n  \r\n\r\n- endWith()\r\n\r\n## 模板字符串\r\n\r\n模板字符串是超级无敌强化之后的字符串,用**间隔符**(ESC下面那个符号)来引用.\r\n\r\n下面简述它的两个主要功能\r\n\r\n1. 可以在字符串内直接使用变量,并计算\r\n2. 可以在字符串内保留回车,不用自己拼接回车了.\r\n\r\n当一个字符串拼接的过长时,原来那种+号的写法过于繁琐,所以可以使用模板字符串,直接把变量放在里面\r\n\r\n\\`\\`\\`javascript\r\n//注意,return中的是间隔符,并不是引号.\r\nfunction KillerQueen(name,age){\r\n\treturn \\`我叫\\${name},今年\\${age}岁\\`\r\n}\r\nconsole.log(KillerQueen(\"吉良吉影\",33));\r\n\\`\\`\\`\r\n\r\n不仅仅是这样,模板字符串里面的变量也可以进行运算,并且保留回车.\r\n\r\n\\`\\`\\`javascript\r\nfunction Real_GDP_per_capita(money){\r\n\treturn \\`\r\n\t\t赵家有钱\\${money}万,隔壁9个穷光蛋;\r\n\t\t平均起来算一算,各个都是赵\\${money/(9+1)}万\\`;\r\n}\r\nconsole.log(Real_GDP_per_capita(1000));\r\n\\`\\`\\`\r\n\r\n\r\n\r\n# 数组\r\n\r\n## 数组常用方法\r\n\r\n1. concat() 可以拼接两个数组\r\n\r\n   \\`\\`\\`javascript\r\n   var loli1 = [\"雷姆\",\"伊莉雅\",\"波莱特\",\"巧克力\"];\r\n   var loli2 = [\"86\",\"香子兰\",\"牛顿\"];\r\n   console.log(loli1.concat(loli2));\r\n   \\`\\`\\`\r\n\r\n   \r\n\r\n# 函数\r\n\r\n## 简介\r\n\r\n​\tJavaScript的函数就是对象,万物皆对象.但是JavaScript是弱数据类型的,所以在使用函数的时候和别的强数据类型语言还是有差别.\r\n\r\n就比如说,函数不用写返回值类型,没有返回值也不用 \\`return void;\\` ,并且定义时需要显式定义.\r\n\r\n## 定义与使用\r\n\r\n函数有两种定义方法(暂时不考虑箭头函数),没有什么好说的,记住就行了.\r\n\r\n\\`\\`\\`javascript\r\nfunction add(a, b) {\r\n\treturn a + b;          \r\n}\r\n//下面这个是字面量创建\r\nvar add = function(a,b){\r\n  return a + b;      \r\n}\r\n\\`\\`\\`\r\n\r\n使用也没有什么好说的,跟其他语言一样\r\n\r\n\\`\\`\\`javascript\r\nadd(a,b);\r\n\\`\\`\\`\r\n\r\n\r\n\r\n## 立即执行函数\r\n\r\n​\t把一个匿名函数前后都用小括号括起来就变成了立即执行函数,这种函数只能用一次,一旦程序运行到这里立刻执行.\r\n\r\n因为没有名字,之后无法被其他程序调用.\r\n\r\n\\`\\`\\`javascript\r\n(function(){\r\n  document.write(\"我是匿名函数\")\r\n})(); \r\n\\`\\`\\`\r\n\r\n\r\n\r\n## 箭头函数\r\n\r\n这个东西看着复杂,实际上就是一个简化版匿名函数,\r\n\r\n我们可以用匿名函数来参考着看.\r\n\r\n\\`\\`\\`javascript \r\nvar fun1 = function (id){\r\n\tconsole.log(\"匿名函数\"+id);\r\n}\r\nvar fun2 = (id) => {\r\n\tconsole.log(\"箭头函数\"+id);\r\n}\r\nfun1(0);\r\nfun2(1);\r\n\\`\\`\\`\r\n\r\n若函数,只有一个参数,可以省略小括号,但是没有参数的话,必须加一个空括号().\r\n\r\n并且函数只有一行代码的话,可以省略大括号,经典操作了.\r\n\r\n\\`\\`\\`javascript\r\nvar fun1 = function (id){\r\n\tconsole.log(\"匿名函数\"+id);\r\n}\r\nvar fun2 = id => console.log(\"箭头函数\");\r\nfun1();\r\nfun2();\r\n\\`\\`\\`\r\n\r\n是不是一下子就简化很多了.但是这个还是有一个需要说明的地方.\r\n\r\n注意!**如果没有大括号,那么编译器默认会给前面加上return,返回该语句.**\r\n\r\n\\`\\`\\`javascript\r\nvar fun2 = () => \"0\"+721;\r\nconsole.log( fun2());\r\n\\`\\`\\`\r\n\r\n最后结果返回0721.(柚子厨震怒)\r\n\r\n## rest参数\r\n\r\n当函数不确定具体有多少参数时,可以使用rest参数,来统一获取剩下所有参数.\r\n\r\n我们用**三个点**代表rest参数 ... \r\n\r\n\\`\\`\\`javascript\r\nfunction Lolis(...lolis){\r\n\tfor(let girl of lolis)\r\n\t\tconsole.log(girl);\r\n}\r\nLolis(\"雷姆\",\"伊莉雅\",\"波莱特\",\"巧克力\");\r\n\\`\\`\\`\r\n\r\n可以发现我在console的时候,用了for of语法,这就说明,其实rest参数会把传进来的所有参数封装成数组,可以用数组的方法操作rest参数.\r\n\r\n## 高阶函数\r\n\r\n\\`\\`\\`javascript\r\nconst nums = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024];\r\n//filter用来过滤想要的数据\r\n//filter函数会调用一个回调函数\r\n//回调函数的参数n会遍历nums数组的元素\r\n//回调函数必须返回一个boolean值,\r\n//若为true则把数据压入新数组,false则过滤掉\r\nvar newNums = nums.filter(\r\n  function (item) {\r\n    if (item > 100)\r\n      return true;\r\n  }\r\n);\r\nconsole.log(\"newNums:\"+newNums);\r\n\r\n//map用来对原数据进行一次映射\r\n//对数组进行一次映射,遍历数组每一项,把数据存入n中,\r\n//return的值存入新的数组\r\nvar newNums2 = newNums.map(\r\n  function (item) {\r\n    return item * 10\r\n  }\r\n);\r\nconsole.log(\"newNums2:\"+newNums2);\r\n\r\n//用于集合中的所有数据,可以进行如全部加一遍的操作\r\n//reduce一共传参两个,第一个是回调函数,第二个是给oldValue初始化的值\r\n//回调函数中,oldValue除第一次外,每次值被赋值为函数return的值\r\n//item依旧遍历之前的数组\r\nvar newNums3 = newNums2.reduce(function (oldValue, item) {\r\n  return oldValue + item;\r\n}, 0);\r\nconsole.log(\"newNums3:\"+newNums3);\r\n\r\nvar totle = nums.filter(function (item) {\r\n  if (item > 100)\r\n    return true;\r\n}\r\n                       ).map(function (item) {\r\n  return item * 10;\r\n}\r\n                            ).reduce(function (oldValue, item) {\r\n  return oldValue+item;\r\n}, 0);\r\nconsole.log(\"totle:\"+totle);\r\n//箭头函数写法\r\nvar totle2=nums.filter(item=>item>100).map(item=>item*10).reduce((pre,item)=>item+pre);\r\nconsole.log(\"totle2:\"+totle2);\r\n\\`\\`\\`\r\n\r\n\r\n\r\n# 引用类型之对象\r\n\r\n# 类\r\n\r\n## 类的创建\r\n\r\n### ES5\r\n\r\n\r\n\r\n### ES6\r\n\r\n类可以来创建对象,因为ES6真的很香,跟java他们用法差不多,现在你就能发现ES6有多香了.S5学起来简直难受的一批,浑身不舒服.\r\n\r\n\\`\\`\\`javascript\r\nclass Loli {\r\n    constructor(age) {\r\n        this.age = age;\r\n    }\r\n\tgulu_gulu()\r\n\t{\r\n\t\tconsole.log(\"咕噜咕噜~~~\");\r\n\t}\r\n\tshowAge(){\r\n\t\tconsole.log(\\`人家今年\\${this.age}岁\\`);\r\n\t}\r\n  //静态方法\r\n\tstatic ne()\r\n\t{\r\n\t\tconsole.log(\"呐呐呐呐呐呐呐呐呐呐呐呐呐呐呐呐\");\r\n\t}\r\n}\r\nvar 巧克力 = new Loli(14);\r\n巧克力.gulu_gulu();\r\n巧克力.showAge();\r\nLoli.ne();\r\n\\`\\`\\`\r\n\r\n可以看到,程序正常运行:\r\n\r\n![image-20200831233256840](img\\image-20200831233256840.png)\r\n\r\n## 类的继承\r\n\r\n用extends表示继承哪个类,之后用super来指定继承的属性,默认继承全部的方法.\r\n\r\n\\`\\`\\`javascript\r\nclass 天然呆萝莉 extends Loli {\r\n\tconstructor(age,name) {\r\n\t\t//用super来直接继承属性\r\n\t  super(age);\r\n\t\tthis.name=name;\r\n\t}\r\n\t//方法默认全部继承过来,无论是普通方法,还是静态方法.\r\n\tshowInfo(){\r\n\t\tconsole.log(\\`嘟嘟噜~~,\\${this.name}です,今年\\${this.age}岁\\`)\r\n\t}\r\n}\r\nvar 椎名真由理 = new 天然呆萝莉(14,\"椎名真由理\");\r\n椎名真由理.showInfo();\r\n椎名真由理.gulu_gulu();\r\n天然呆萝莉.ne();\r\n\\`\\`\\`\r\n可以看到程序正常运行:\r\n\r\n![image-20200831233416082](img\\image-20200831233416082.png)\r\n\r\n# this\r\n\r\n精通this是你从JS萌新变成JS巨佬的必经之路,但是想熟练掌握这个东西,并不是一件轻松的工作..\r\n\r\n\r\n# JSON\r\n\r\n# BOM和DOM\r\n\r\n`","<template>\r\n  <div>\r\n    <markdown-it-vue class=\"md-body\" :content=\"content\"/>\r\n  </div>\r\n</template>\r\n \r\n<script>\r\nimport MarkdownItVue from 'markdown-it-vue'\r\nimport 'markdown-it-vue/dist/markdown-it-vue.css'\r\nimport MdFile from \"./JavaScript.js\"\r\nexport default {\r\n  components: {\r\n    MarkdownItVue\r\n  },\r\n  data () {\r\n    return {\r\n\t\t\tcontent: MdFile\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n\t\r\n</style>","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./JavaScript.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./JavaScript.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./JavaScript.vue?vue&type=template&id=0c0bfa68&\"\nimport script from \"./JavaScript.vue?vue&type=script&lang=js&\"\nexport * from \"./JavaScript.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}